{"meta":{"title":"侯先森的Blog","subtitle":"","description":"","author":"侯振宇","url":"https://bj-houzhenyu.github.io","root":"/"},"pages":[{"title":"我的朋友们（该功能模块暂未开放哦~）","date":"2020-05-03T14:45:26.892Z","updated":"2020-05-03T14:45:26.892Z","comments":false,"path":"friends/index.html","permalink":"https://bj-houzhenyu.github.io/friends/","excerpt":"","text":""},{"title":"所有分类","date":"2020-05-01T08:34:11.230Z","updated":"2020-05-01T08:34:11.230Z","comments":true,"path":"categories/index.html","permalink":"https://bj-houzhenyu.github.io/categories/","excerpt":"","text":"​ 这是分类页面"},{"title":"关于","date":"2020-05-17T14:04:57.577Z","updated":"2020-05-17T14:04:57.577Z","comments":true,"path":"about/index.html","permalink":"https://bj-houzhenyu.github.io/about/","excerpt":"","text":"Hello大家好！！ 先放一张自己最喜欢的游戏图~哈哈，挚爱 塞尔达荒野之息 热爱生活，喜欢玩游戏，享受于科技带来的节奏，在这个不可思议的时代，科技创新技术掌握着我们的未来； 喜欢听歌，喜欢电影，喜欢在假期窝在沙发里 享受 安静；也喜欢和朋友们一起疯！ 程序员，并不是闷闷不乐，拖鞋格子衫 程序员，也可以酷乐潮玩，摄影后期男 我只是普通的前端攻城狮​ 出生于94年，来自山西的一个小山城-阳泉；经历过高四到达了长沙（一个值得怀念的美丽城市），毕业于长沙理工大学电子信息专业，毕业后的我毅然决然来到了北京，寻梦与努力，想过放弃，一个人在这个偌大的城市，疲惫过，开心过… ​ 我会努力，也会把自己的点滴，工作的经验，分享在这个无人问津的博客上，等到有一天，回想起来，也是一种财富吧。 ​ 在写之前会有一堆话想敲下来，但是真正坐在这里，却又不知要怎么写，我还是分享总结规整更多的知识点给大家，更新有些慢，也是随性啦！！！"},{"title":"","date":"2020-05-01T08:35:32.173Z","updated":"2020-05-01T08:35:32.173Z","comments":true,"path":"mylist/index.html","permalink":"https://bj-houzhenyu.github.io/mylist/","excerpt":"","text":""},{"title":"所有标签","date":"2020-05-01T08:34:59.645Z","updated":"2020-05-01T08:34:59.645Z","comments":true,"path":"tags/index.html","permalink":"https://bj-houzhenyu.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"那些必会的js最佳做法——创建对象","slug":"20200517","date":"2020-05-17T14:22:01.842Z","updated":"2020-05-17T14:23:07.086Z","comments":true,"path":"2020/05/17/20200517/","link":"","permalink":"https://bj-houzhenyu.github.io/2020/05/17/20200517/","excerpt":"​ 这几天正在翻看一些公司的招聘信息，看到很多都有一条要求掌握面向对象编程！确实面向对象是每个前端工程师必备的技能，在这里就简单写一下我理解的，分享给大家，面向对象编程并不是一下两下就能说清楚，所以这只是第一篇哦！ JavaScript是一种非常宽容的语言。编写即使有些小错误的代码，依然可以很容易的运行。 在本文中，我们将探讨创建JavaScript对象的最佳方法，而不是通过使用Object构造函数。","text":"​ 这几天正在翻看一些公司的招聘信息，看到很多都有一条要求掌握面向对象编程！确实面向对象是每个前端工程师必备的技能，在这里就简单写一下我理解的，分享给大家，面向对象编程并不是一下两下就能说清楚，所以这只是第一篇哦！ JavaScript是一种非常宽容的语言。编写即使有些小错误的代码，依然可以很容易的运行。 在本文中，我们将探讨创建JavaScript对象的最佳方法，而不是通过使用Object构造函数。 Don’t use the Object 建设者Object构造函数允许我们创建一个对象。但是，由于有更短的创建对象的方法，因此不需要创建对象。例如，代替使用Object构造函数创建对象来编写以下内容，我们可以编写为： 123const obj = new Object（）;obj.a = 1;obj.b = 2; 我们也可以这样写： 1234const obj = &#123; a：1， b：2&#125;; 如我们所见，通过直接创建对象文字而不是使用Object构造函数，我们避免了很多额外的代码输入。 我们还可以创建构造函数或类来创建模板函数，以用于创建新对象。 例如，我们可以Person使用类语法创建构造函数，以便可以Person使用new运算符创建新的对象。 我们可以编写以下代码来创建Person构造函数： 12345class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125; 在上面的类中，我们有name用于在name实例中设置实例变量的参数Person。 然后，我们可以Person使用它创建多个实例，如下所示： 123const jane = new Person（'jane'）;const joe = new Person（'joe'）;const alex = new Person（'alex'）; 在上面的代码中，我们创建了3个新Person实例，它们具有不同的值，this.name这些值是通过name参数传递的。 我们还可以通过编写以下代码将实例方法添加到类中： 12345678class Person &#123; constructor(name) &#123; this.name = name; &#125; greet(greeting) &#123; return `$&#123;greeting&#125; $&#123;this.name&#125;`; &#125;&#125; 在上面的代码中，我们有greetinstance方法，该方法接受一个greeting字符串并将其与this.nameinstance变量组合。 然后我们可以这样称呼它： 123console.log（jane.greet（'hi'））;console.log（joe.greet（'hi'））;console.log（alex.greet（'hi'））; 然后我们得到： 123hi janehi joehi alex 记录在控制台日志输出中，如我们所说greet的那样传递’hi’为的值greeting。 如我们所见，使用JavaScript类，我们可以创建具有相同实例变量和方法的对象。 创建对象的另一种方法是使用Object.create方法。此方法很有用，因为我们可以在创建对象时设置对象的原型。 例如，如果我们要创建一个以另一个对象作为原型的对象，则可以编写以下代码： 123456const bar = &#123; a：1&#125;const foo = Object.create（bar）;foo.b = 1;foo.c = 2; 在上面的代码中，我们有了bar对象，该foo对象通过使用Object.create方法用作对象的原型。 然后我们增加额外的属性b和c对foo对象本身。b并且c是foo自己的，还是非继承财产，a是原型的财产foo。 原型是子对象的模板对象。对象从其原型继承属性。 如果我们记录该foo对象，则会得到foo的proto属性具有a其值设置为1的属性。 如果要创建没有原型的对象，则可以Object.create使用参数调用该方法，null以便proto不设置该属性。 例如，我们可以编写以下代码来创建对象： 123const foo = Object.create（null）;foo.b = 1;foo.c = 2; 然后，如果我们记录的值foo，我们将看到它没有proto属性，这意味着该对象没有原型。 结论有很多方法可以简洁地创建对象。我们不应该只使用Object构造函数来创建对象。 这是因为与定义对象文字相比，它没有任何好处。它们都继承Object和使用构造函数是完成同一件事，但他们各自方法有所不同。 创建对象的替代方法，包括使用类作为新对象的模板。 最后，我们可以使用Object.create来创建具有所需原型的对象。","categories":[{"name":"前端小伎俩","slug":"前端小伎俩","permalink":"https://bj-houzhenyu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B0%8F%E4%BC%8E%E4%BF%A9/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://bj-houzhenyu.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"如何避免在javaScript中避免使用大量if语句~！","slug":"20200516","date":"2020-05-16T08:00:21.792Z","updated":"2020-05-16T08:15:02.166Z","comments":true,"path":"2020/05/16/20200516/","link":"","permalink":"https://bj-houzhenyu.github.io/2020/05/16/20200516/","excerpt":"​ 为什么要分享这篇文章呢，是因为前一个月公司有项目重构，在简化优化代码的同时发现代码中有大量的 if 语句，这会让人有时候觉得很痛苦。其实，在很多地方，我们可以不需要它们。我们可以将if语句替换为其他类型的代码，以使我们的代码更短，更清晰。","text":"​ 为什么要分享这篇文章呢，是因为前一个月公司有项目重构，在简化优化代码的同时发现代码中有大量的 if 语句，这会让人有时候觉得很痛苦。其实，在很多地方，我们可以不需要它们。我们可以将if语句替换为其他类型的代码，以使我们的代码更短，更清晰。 三元运算符 如果我们要返回具有一个条件的一个事件，否则返回其他东西，则三元运算符很有用。 例如，我们可以这样写： 1const bar = foo ? 'foo' : 'bar'; 在上面的代码中，如果foo为true，则返回’foo’。否则，我们返回’bar’。 然后，如果foo为true，则bar为’foo’。否则，bar为’bar’。 上面代码比以下简短得多： 123456const bar = ((foo) =&gt; &#123; if (foo) &#123; return 'foo' &#125; return 'bar'&#125;)(foo); 使用三元运算符，我们不必使用内部if语句定义一个匿名函数，如果foo为true，则返回“ foo”，否则返回“ bar”。 另外，定义后，我们不必立即使用foo调用它。因此，它更容易读写。 但是，我们不应该通过嵌套它们来滥用三元运算符： 1const foo = a ? b ? c ? 'foo' : 'bar' : 'baz' : 'qux'; 上面的代码很难阅读，因为我们必须在括号内加括号以在我们自己的脑海中划定界限。 这在我们的大脑上很难解决，因此我们不应该采用上述表达。 短路表达式 我们将使用&amp;&amp;或|| 的操作员称为短路操作员。 如果第一个操作数为真，则&amp;&amp;运算符对于在第二个操作数中运行代码很有用。|| 如果第一个操作数为false，则运算符对于在第二个操作数中运行代码很有用。 例如，我们可以按以下方式使用它： 12345const isOnline = true;const makeRequest = () =&gt; &#123; //...&#125;isOnline &amp;&amp; makeRequest(); 在上面的代码中，如果isOnline为true，则调用makeRequest。因此，由于isOnline为true，所以我们调用makeRequest函数。 这将替换以下if语句： 1if (isOnline) &#123; makeRequest();&#125; 如我们所见，在使用相同的isOnline和makeRequest值的情况下，使用if语句需要3行代码来完成相同的操作。 与|| 运算符，如果第一个操作数为false，则可以使用它来设置默认值。 例如，我们可以编写以下代码： 12const foo = null;const bar = foo || 'abc'; 在上面的代码中，我们将foo设置为null，这是false。因此，在第二行，|| 运算符将计算foo常量，该常量为null，因此也为false。 然后，由于它是false，它将继续评估第二个操作数，然后将其返回。 因此，bar的值为’abc’。编码： 1const bar = foo || 'abc'; 替换以下代码： 123456const bar = ((foo) =&gt; &#123; if (!foo) &#123; return 'abc' &#125; return foo;&#125;)(foo) 如我们所见，我们必须定义一个匿名函数，然后调用它。 该函数将foo作为参数，然后在其内部检查foo是否虚假。如果是虚假的，那么我们返回’abc’。否则，我们返回foo。 ||的替代品 运算符更长，更复杂。 避免使用switch语句 switch语句的许多用法可以用更简单的方法代替。例如，代替编写以下switch语句： 123456789101112const getDescription = (breed) =&gt; &#123; switch (breed) &#123; case 'border': return 'kind dog'; case 'pitbull': return 'angry dog'; case 'german': return 'smart dog'; default: return '' &#125;&#125;const desc = getDescription('border'); 我们可以将值放在对象中，如下所示： 123456const descs = &#123; 'border': 'kind dog', 'pitbull': 'angry dog', 'german': 'smart dog',&#125;const desc = descs['border'] 在上面的代码中，我们将case值作为属性，将返回值作为属性的值。 然后，我们可以像在最后一行中一样获取值，而不用调用longyswitch语句。 如果要获取默认情况，可以使用||。如下： 1const desc = descs['foo'] || ''; 现在，我们将一个长的switch语句缩小为一个小对象。 结论 在许多情况下，我们可以减少if并将语句切换为较短的代码。我们应该记住要使用三元运算符，短路运算和将switch语句更改为字典对象的快捷方式，以使我们的代码更短，更清晰。","categories":[{"name":"前端小伎俩","slug":"前端小伎俩","permalink":"https://bj-houzhenyu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B0%8F%E4%BC%8E%E4%BF%A9/"}],"tags":[{"name":"优化代码","slug":"优化代码","permalink":"https://bj-houzhenyu.github.io/tags/%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/"}]},{"title":"前端必会的mysql讲解","slug":"MySQL01","date":"2020-05-06T16:36:36.397Z","updated":"2020-05-06T16:48:56.453Z","comments":true,"path":"2020/05/07/MySQL01/","link":"","permalink":"https://bj-houzhenyu.github.io/2020/05/07/MySQL01/","excerpt":"随着现在前端开发人员与日俱增，社会如此美好，技术如此高超，不掌握一门神奇的语言怎么对得起将来的自己？？如果你曾几何时想自己开发简单服务器，那必少不了对数据库的操作，推荐Mysql~（如果看不懂最后的Node-mysql也别急，后期会慢慢来维护我的博客，对其分类总结哒！以后会找时间认证讲解Node.js，大家先学一下数据库操作吧，码起来！！）","text":"随着现在前端开发人员与日俱增，社会如此美好，技术如此高超，不掌握一门神奇的语言怎么对得起将来的自己？？如果你曾几何时想自己开发简单服务器，那必少不了对数据库的操作，推荐Mysql~（如果看不懂最后的Node-mysql也别急，后期会慢慢来维护我的博客，对其分类总结哒！以后会找时间认证讲解Node.js，大家先学一下数据库操作吧，码起来！！） MySQL数据库 MySQL数据库入门未来我们程序中的数据为了方便管理都通过数据库来存储。 作为前端开发人员，对数据库做一定了解即可。 数据库基础知识 什么是数据库 存储数据的仓库 使用数据库管理数据的好处 方便存储、查询、修改、删除 关系型数据库 MySQL Sql Server Orcale SQLite 数据表 二维的表，类似于Excel表 由行和列组成，列：字段，行：记录 字段的类型 int 整数、double 浮点数、varchar(255) 字符串、text 文本、datetime 日期、float 浮点数 MySQL 的服务器 下载地址： https://dev.mysql.com/downloads/mysql/5.7.html#downloads MySQL 安装与配置 准备工作 在 C 盘根目录建立目录： c:\\develop 解压并移动位置 解压缩 mysql-5.7.23 的压缩包，将其中的 mysql-5.7.23-xxxxx 目录移动到 C:\\develop 目录下并把名字修改为 mysql MySQL 的配置文件 my.ini 在 c:\\develop\\mysql 目录下新建一个 my.ini 的配置文件 1234567[mysqld]# MySQL 安装目录basedir=C:/develop/mysql# 数据文件所在目录datadir=C:/develop/mysql/datacharacter-set-server=utf8sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\" 以管理员身份运行 CMD 执行以下命令，安装一个 MySQL 服务 12345# 定位到安装目录下的 bin 文件夹# cd &lt;MySQL安装目录&gt;\\bincd c:\\develep\\mysql\\bin# 初始化数据所需文件以及获取一个临时的访问密码mysqld --initialize --user=mysql --console 初始化成功如下图：记下临时密码(只能使用一次) 12345678# 将 MySQL 安装为服务 可以指定服务名称mysqld --install MySQL# 没有以管理员的身份运行命令行# 安装失败提示：Install/Remove of the Service Denied! # 安装成功后，启动 MySQL 服务器net start MySQL 重置 MySQL 密码 123456# 先通过用户名密码进入 MySQL 操作环境mysql -u root -pEnter password: # 输入临时密码# 设置数据库访问密码，一定要加分号mysql&gt; set password for root@localhost = password('*******'); MySQL 的客户端 数据库的客户端 Navicat 使用 Navicat 创建数据库 使用 Navicat 创建表，添加数据 SQL要在程序中对数据库进行操作需要 SQL 语句 什么是 SQL SQL 指结构化查询语言 SQL 使我们有能力访问数据库 参考网站 增删改查 插入数据 1234INSERT INTO users (uname, upwd, uqq) values('zs','123', '12345')INSERT INTO posts SET uname='zs', upwd='123', uqq='12345'-- 如果是所有列，可以省略列名称，不推荐INSERT INTO users values('zs','123', '12345') 修改数据 1UPDATE users SET uname='zsxxx', uqq='111' WHERE uid=1 删除数据 123DELETE FROM users WHERE uid = 1-- 不带条件删除表中所有数据，禁止使用DELETE FROM users 查询数据 1SELECT * FROM users 查询 条件查询 123SELECT * FROM users WHERE uname='zs' AND uname='000000'SELECT * FROM users WHERE uname='zs' OR uname='ls' 下面的运算符可在 WHERE 子句中使用： 操作符 描述 = 等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 模糊查询 1SELECT * FROM users WHERE uname like '%s%' in 语句 1SELECT * FROM users WHERE uname in ('zs','ls') 排序 order by 要写在 sql 语句的最后 123-- asc 升序 desc 降序SELECT * FROM users ORDER BY DESCSELECT * FROM users WHERE uage &gt; 18 ORDER by desc 限制查询条数 123456-- 取前3条数据SELECT * FROM users LIMIT 3 -- 降序后去3条数据SELECT * FROM users ORDER BY DESC LIMIT 3-- 跳过3条，取2条SELECT * FROM users ORDER BY DESC LIMIT 3,2 获取总条数 1SELECT COUNT(*) FROM users 表连接 1234SELECT column_name(s)FROM table_name1INNER JOIN table_name2 ON table_name1.column_name=table_name2.column_name Node.js 中操作 MySQL使用 mysql 第三方包https://github.com/mysqljs/mysql 安装1npm install mysql Hello World12345678910111213141516var mysql = require('mysql');var connection = mysql.createConnection(&#123; host : 'localhost', user : 'me', password : 'secret', database : 'my_db'&#125;);connection.connect();connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) &#123; if (error) throw error; console.log('The solution is: ', results[0].solution);&#125;);connection.end(); 增删改查查询基本查询： 12345connection.query('SELECT * FROM `books` WHERE `author` = \"David\"', function (error, results, fields) &#123; // error will be an Error if one occurred during the query // results will contain the results of the query // fields will contain information about the returned results fields (if any)&#125;); 条件查询： 12345connection.query('SELECT * FROM `books` WHERE `author` = ?', ['David'], function (error, results, fields) &#123; // error will be an Error if one occurred during the query // results will contain the results of the query // fields will contain information about the returned results fields (if any)&#125;); 添加123456var post = &#123;id: 1, title: 'Hello MySQL'&#125;;var query = connection.query('INSERT INTO posts SET ?', post, function (error, results, fields) &#123; if (error) throw error; // Neat!&#125;);console.log(query.sql); // INSERT INTO posts SET `id` = 1, `title` = 'Hello MySQL' 删除1234connection.query('DELETE FROM posts WHERE title = \"wrong\"', function (error, results, fields) &#123; if (error) throw error; console.log('deleted ' + results.affectedRows + ' rows');&#125;) 修改1234connection.query('UPDATE users SET foo = ?, bar = ?, baz = ? WHERE id = ?', ['a', 'b', 'c', userId], function (error, results, fields) &#123; if (error) throw error; // ...&#125;) 封装 dbHelper.js1234567891011121314151617const mysql = require('mysql');var connection = mysql.createConnection(&#123; host : 'localhost', port : 3306, user : 'root', password : 'root', database : 'guestbook'&#125;);exports.query = (sql, params, callback) =&gt; &#123; connection.connect(); connection.query(sql, params, function (error, results, fields) &#123; callback(error, results, fields); &#125;); connection.end();&#125;;","categories":[{"name":"前端小伎俩","slug":"前端小伎俩","permalink":"https://bj-houzhenyu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B0%8F%E4%BC%8E%E4%BF%A9/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://bj-houzhenyu.github.io/tags/MySQL/"}]},{"title":"别人家的孩子—ifream","slug":"ifream01","date":"2020-05-03T13:43:45.000Z","updated":"2020-05-03T14:39:57.818Z","comments":true,"path":"2020/05/03/ifream01/","link":"","permalink":"https://bj-houzhenyu.github.io/2020/05/03/ifream01/","excerpt":"说起iframe，大家都会觉得很嫌弃或者很不愿接近，原因大概都是：能耗高，安全问题，spider不喜欢它…也有（不少）同学内心独白就是：不！这很low很dirty，我才不想用惹！但是我们必须的承认iframe之强大，很多时候我们都会（不得不）使用它，真的素又爱又恨呐-8-","text":"说起iframe，大家都会觉得很嫌弃或者很不愿接近，原因大概都是：能耗高，安全问题，spider不喜欢它…也有（不少）同学内心独白就是：不！这很low很dirty，我才不想用惹！但是我们必须的承认iframe之强大，很多时候我们都会（不得不）使用它，真的素又爱又恨呐-8- 不得不吐槽一下我的刚进入公司时，是充满了疑惑和惊喜，被指派修改后端框架所带来的各种样式问题与兼容性问题，那会公司用的框架分别是 jeecg bex5 ，充满了iframe；感兴趣的童鞋可以去搜一下这两个，对于一个出生前端的程序员来说，坐在那里就是一脸懵逼，没办法，那段昏暗的日子是百度陪我度过的，不会就学，不懂就问！ 今天就在这里和大家一起好好讨论一下iframe。 iframe基本概念 我们先看一个🌰 1&lt;iframe src=\"demo.html\" height=\"300\" width=\"500\" name=\"demo\" scrolling=\"auto\" sandbox=\"allow-same-origin\"&gt;&lt;/iframe&gt; iframe的一些基本属性： src iframe页面地址，有同域跨域之分 height iframe高度 width iframe宽度 name iframe命名，可通过window.frames[xxx]被调用 scrolling iframe滚动模式 sandbox html5新特性，用于限制iframe的功能 使用iframe的正确姿势 我们可以通过contentWindow和contentDocument两个API获取iframe的window对象和document对象。 123let iframe = document.getElementById('demo');let iwindow = iframe.contentWindow; // 获取iframe的window对象let idoc = iframe.contentDocument; // 获取iframe的document对象 刚刚我们提到了iframe的name属性，我们也可以通过window.frames[iframeName]来调用iframe。 1let iframe = window.frames['demo'] iframe使用父级内容的正确姿势我们通过window.self，window.parent，window.top这三个属性分别获取自身window对象，父级window对象，顶级window对象。 看图说话 1234iframe1.self === iframe1iframe1.parent === iframe2iframe2.parent === windowiframe1.top === window 同域/跨域什么是同域什么跨域咧？同域跨域的区别在哪咧？我们一般会使用iframe来进行父子页面的通信，然鹅父子页面是否同域决定了它们之间能否进行通信。 js遵循同源策略，即同协议，同域名，同端口号，否则都算跨域。 同源策略 是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。实际上，这种策略只是一个规范，并不是强制要求，各大厂商的浏览器只是针对同源策略的一种实现。它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。 跨域 简单的来说，指的是两个资源非同源。出于安全方面的考虑，页面中的JavaScript在请求非同源的资源时就会出 跨域问题 ——即跨域请求，这时，由于同源策略，我们的请求会被浏览器禁止。也就出现了 我们常说的 跨域 问题。 iframe跨域通讯之document.domain对于主域相同子域不同的两个页面，我们可以通过document.domain + iframe来解决跨域通信问题。 举个🌰，网页a(http://www.easonwong.com)和网页b(http://script.easonwong.com)，两者都设置`document.domain = ‘easonwong.com’`（这样浏览器就会认为它们处于同一个域下），然后网页a再创建iframe上网页b，就可以进行通信啦～！ 网页a 123456789document.domain = 'easonwong.com';var ifr = document.createElement('iframe');ifr.src = 'http://script.easonwong.com';ifr.style.display = 'none';document.body.appendChild(ifr);ifr.onload = function()&#123; let doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html&#125;; 网页b 1document.domain = 'easonwong.com'; iframe跨域通讯之postMessagepostMessage是html5的新特性，具体介绍不在此赘述。 我们可以通过html5这个新特性进行iframe间的跨域通信，使用postMessage进行数据传递，通过Message监听通信事件。举个🌰 网页a 1234567document.domain = 'easonwong.com';var ifr = document.createElement('iframe');ifr.src = 'http://script.easonwong.com';ifr.style.display = 'none';document.body.appendChild(ifr);// 发送数据ifr.postmessage('hello, I`m a', 'http://script.easonwong.com'); 网页b 123456789// 监听message事件window.addEventListener('message', receiver, false);function receiver(e) &#123; if (e.origin == 'http://www.easonwong.com') &#123; if (e.data == 'hello, I`m a') &#123; e.source.postMessage('hello, I`m b', e.origin);信息 &#125; &#125;&#125; iframe实现JSBridge在移动端Hybrid混合模式中经常用到JSBridge进行JS和Native之间的通信，其中我们可以通过iframe的方式实现JS调用Native的方法。 以上提到的方法就是URL SCHEME拦截。 URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: easonwong://hh/url?name=easonwong，其中protocol是easonwong，host则是hh。 我们通过创建一个iframe（src设为我们自定义的URL SCHEME）来发送请求，然后Native那边可以拦截到请求并获取其中带有的参数，即可进行后续的操作。 iframe的其他用途 用iframe进行异步请求 在很久很久很久以前，久到ajax还没出现的时候，人们会用iframe来进行异步请求。大概就是异步创建iframe，然后后台返回数据在iframe中，我们在从里面获取数据。 例如在我做过的一个项目中，通过iframe.src传入一个文件下载地址，实现无需打开新窗口下载文件。 引用/展示第三方内容 需要独立样式和带有交互的内容，例如幻灯片 sandbox沙箱隔离 历史记录管理 iframe的安全问题iframe小广告很让我们讨厌iframe的一点，就是很多*网站都会有各种让人防不胜防的小广告，它们大多就是用通过iframe实现的，本来想点击某个播放按钮，结果马鸭直接跳几十跳不知道去了哪个新世界去了。 更讨厌的一种情况是，可能不知道哪天用户突然拿刀过来，说我们的项目页面里出现了野鸡广告，说我们在消费他们，一脸懵逼的我们觉得十分无辜。实际上就是我们的页面被运行商劫持了，被挂上了注入了不知名的野鸡广告。 所以我们一定要注意在用iframe的同时，要防止我们被iframe了。 防嵌套页面操作在前端领域，我们可以通过window.top来防止我们页面被嵌套。 123if(window != window.top)&#123; window.top.location.href = myURL;&#125; 或者通过window.location.host来检测是否跨域了 123if (top.location.host != window.location.host) &#123; top.location.href = window.location.href;&#125; 而后端也可以做对应的防范措施，通过设置X-Frame-Options响应头来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。 CSP 内容安全策略（CSP）用于检测和减轻用于 Web 站点的特定类型的攻击，例如 XSS 和数据注入等。 MDN CSP 通过CSP配置sandbox和child-src可以设置iframe的有效地址，它限制适iframe的行为，包括阻止弹出窗口,防止插件和脚本的执行,而且可以执行一个同源策略。 用法 我们可以在html头部中加上``标签 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"child-src 'unsafe-inline' 'unsafe-eval' www.easonwong.com\"&gt; 或者通过HTTP头部信息加上Content-Security-Policy字段 参考文章Iframe 有什么好处，有什么坏处 。","categories":[{"name":"前端小伎俩","slug":"前端小伎俩","permalink":"https://bj-houzhenyu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B0%8F%E4%BC%8E%E4%BF%A9/"}],"tags":[{"name":"iframe","slug":"iframe","permalink":"https://bj-houzhenyu.github.io/tags/iframe/"}]},{"title":"优秀前端必备的Linux冷门知识？！","slug":"Linux01","date":"2020-05-02T16:00:00.000Z","updated":"2020-05-03T14:40:55.482Z","comments":true,"path":"2020/05/03/Linux01/","link":"","permalink":"https://bj-houzhenyu.github.io/2020/05/03/Linux01/","excerpt":"前端工程师需要对Linux掌握到什么程度？ 我的回答是：前端切图仔根本就不需要掌握Linux，但合格的前端工程师是需要掌握一些必要的Linux命令的！","text":"前端工程师需要对Linux掌握到什么程度？ 我的回答是：前端切图仔根本就不需要掌握Linux，但合格的前端工程师是需要掌握一些必要的Linux命令的！ 随着业务架构演进，服务端和客户端的渲染层均交由FEer处理，越来越多的前端开始接触Linux，做一些安装部署NodeJS项目之类的工作，本篇的主要内容就是介绍Linux下的基础知识和常用命令，帮助前端工程师在服务器中自由自在的傲游。 说起Linux，作为一名长时间混迹IT圈的朋友们想必都听过了解过，这里引一下官方说明 ​ “Linux是一套免费使用和自由传播的开源程序，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。被广泛的用于服务器、安卓系统等其它各种设备系统中所使用。” 发行版 目前互联网公司使用的发行版主要是如下三个 CentOS Debian Ubuntu 如何知道一台机器的发行版？ 1lsb_release -a 想知道一台机器的基本信息（内核版本等）？ 1uname -a 基本概念用户与用户组 在Linux下，每个用户都属于一个用户组。文件和目录的读写权限等会根据用户和用户组来区分。对于组外的用户，称之为 其他用户 `。 目录在Linux下目录是一等公民，万物开始于/。我们先说明一下系统根目录下常规的一些文件夹都是做什么的？详情见这张表 目录名 简介 /opt 第三方软件 /bin 一般用户可用一些执行文件 /sbin 一些系统执行文件 /tmp 临时文件 /home 一般用户的文件目录 /root root用户的文件目录 /boot 内核文件和开机引导程序等 /dev 设备文件 /etc 各种软件的配置文件和启动脚本 /lib 一些系统依赖的库 /usr 一些系统软件所在目录 /var 一些系统的日志文件和缓存文件 上面这张表中/boot目录以上的是我们一定要理解清楚的目录，至于/boot及以下的目录只需大概了解就好。 包管理工具每个平台下有自己的包管理工具，作为一个常用Mac的前端工程师，你一定知道Homebrew，自己也常常brew install，安完就能在命令行中使用了，非常方便。Homebrew默认的源是在海外的，很慢很慢，所以大家一般会替换为国内的源，就跟npm切成淘宝源一个意思。 为什么扯这么多Mac上的东西那？原因在于，这套包管理机制和Linux各个发行版是一致的。各个发行版中推荐使用的包管理工具如下 CentOS -&gt; yum Debian -&gt; apt-get Ubuntu -&gt; apt-get 通过包管理工具，可以轻松安装相应的包，直接就可以在命令行中使用。 其他还有一些相应格式安装包对应的安装工具，比如用于安装.deb文件的dpkg，还有用于安装.rpm文件的rpm。 包的其实也不是什么高深的东西？其实就是一个或多个拥有可执行权限的文件，比如我们执行node命令，实际上就是执行了一个可执行的二进制文件。 我们可以使用which命令查看可执行文件在哪里？例如which node 基本命令帮助命令man绝大部分的软件安装都为执行程序提供了帮助手册编译安装的软件，可以配置/etc/man.config指定man手册路径 man命令大多给出的文档非常详细，可能有的时候并不想详读，这时候推荐使用tldr查看帮助文档。tldr是一个在线的帮助文档工具，提供的文档比较社区化，简短易懂，悲伤的是Linux机器上默认是没有tldr的，需要自己安装下，详细文档在这里。 目录&amp;文件命令 命令 简介 示例 cp 复制文件/目录 cp path/to/file.ext path/to/copy.ext cp path/to/file.ext path/to/copy rm 删除文件/目录 rm path/to/file rm -r path/to/folder mv 移动文件/目录 mv source target which 查找命了文件所在位置 which node find 查找文件或目录 find root_path -name &#39;*.ext&#39; find root_path -size +500k -size -10MB ln 创建文件/目录的链接 ln node-v6.2 node touch 新建空文件 touch filename file 查看文件类型 file filename pwd 查看当前工作目录 pwd cd 切换工作目录 cd /path ls 显示目录内容 ls -lh mkdir 创建新的目录 mkdir –p /directory du 统计目录及文件的空间占用情况 du -sh du -h --max-depth=N path/to/folder Tips: 几个常见的命令行参数-h -human-readable 以人能看懂的方式展示-r 递归文件夹-f -force 强制 内容查看命令 命令 简介 示例 cat 查看显示文件内容 cat filename more/less 分页查看文件内容 less filename head/tail 查看文件开头/末尾的部分内容 tail -f web.log wc 统计文件内容的单词数量等信息 grep 检索过滤文件内容 cat package.json grep &#39;vue&#39; 在文件查看命令中，我个人最推荐使用less命令，比较强大，基本可以满足我个人的所有需求 此为第一节全部内容，下一节我将详细介绍一些进程管理，CPU，内存使用量相关的命令，敬请期待。","categories":[{"name":"前端小伎俩","slug":"前端小伎俩","permalink":"https://bj-houzhenyu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B0%8F%E4%BC%8E%E4%BF%A9/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://bj-houzhenyu.github.io/tags/Linux/"}]},{"title":"世间美好~我的第一条博客","slug":"20200501","date":"2020-05-01T15:56:49.837Z","updated":"2020-05-03T14:39:17.754Z","comments":true,"path":"2020/05/01/20200501/","link":"","permalink":"https://bj-houzhenyu.github.io/2020/05/01/20200501/","excerpt":"Hello~大家好，我是小猴子，在过去很长的一段时间里，一直想建立一个属于自己的博客。","text":"Hello~大家好，我是小猴子，在过去很长的一段时间里，一直想建立一个属于自己的博客。 在这个科技发达的世界里，微博、朋友圈、抖音、知乎、豆瓣~！都是可以分享自己故事的优秀平台，为什么我还要这样搭建自己的博客呢？ 可能是想要更加自由，分享一些前端的小技巧，分享一些好听的音乐，分享一些生活的趣事~ 我是一名94年的前端攻城狮，曾在美丽的长沙度过自己大学四年时光，毅然来到北京这座充满机遇挑战的大城市，在北京度过了自己的两年时光，这两年我收获了很多，从茫然到坚定，从幼稚到成熟，从懒散到努力。马云爸爸说过 人们必须认识到，社会是最好的大学，错误是最好的老师。 没错，这两年我也有过后悔，有过失望，也有想过放弃… 但是人生不就是用来努力换取幸福的一的过程嘛？ 19年初就曾想过建立博客，奈何工作繁忙，常常加班，趁着想要换一个工作，在这段重新选择的空隙中，把自己的博客地基搭建起来啦~，（其他功能慢慢来吧=。=）。好在自己平时喜欢记录，以后呢，也会把曾经的故事心得分享在博客上，分享一些自己的工作经验，给想步入这行的小白们一些启示；也会总结分享一些技巧教程，路漫漫其修远兮，吾将上下而求索 。 这是我博客的第一篇文章，只是为了测试出来的页面效果。。嘻嘻嘻 对了，祝大家五一快乐，劳动最光荣！","categories":[{"name":"生活类","slug":"生活类","permalink":"https://bj-houzhenyu.github.io/categories/%E7%94%9F%E6%B4%BB%E7%B1%BB/"}],"tags":[{"name":"初识","slug":"初识","permalink":"https://bj-houzhenyu.github.io/tags/%E5%88%9D%E8%AF%86/"}]}],"categories":[{"name":"前端小伎俩","slug":"前端小伎俩","permalink":"https://bj-houzhenyu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B0%8F%E4%BC%8E%E4%BF%A9/"},{"name":"生活类","slug":"生活类","permalink":"https://bj-houzhenyu.github.io/categories/%E7%94%9F%E6%B4%BB%E7%B1%BB/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://bj-houzhenyu.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"优化代码","slug":"优化代码","permalink":"https://bj-houzhenyu.github.io/tags/%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/"},{"name":"MySQL","slug":"MySQL","permalink":"https://bj-houzhenyu.github.io/tags/MySQL/"},{"name":"iframe","slug":"iframe","permalink":"https://bj-houzhenyu.github.io/tags/iframe/"},{"name":"Linux","slug":"Linux","permalink":"https://bj-houzhenyu.github.io/tags/Linux/"},{"name":"初识","slug":"初识","permalink":"https://bj-houzhenyu.github.io/tags/%E5%88%9D%E8%AF%86/"}]}